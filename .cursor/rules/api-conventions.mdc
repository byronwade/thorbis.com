---
globs: **/api/**/route.ts,**/api/**/route.js,**/*api-client*,**/*openapi*
description: API development conventions and patterns for industry-separated Thorbis APIs
---

# Thorbis API Development Conventions

## API Architecture Principles

### Industry Namespace Separation
- **Each industry has dedicated API namespaces**: `/api/hs/`, `/api/rest/`, `/api/auto/`, `/api/ret/`
- **Public vs App API separation**: Public truth layer + tenant-scoped app APIs
- **Consistent patterns**: Same structure and conventions across all industries
- **No cross-industry API calls**: Each industry API is self-contained

### API Structure Standards

```
/api/[industry]/public/v1/*     # Public truth layer (no auth required)
/api/[industry]/app/v1/*        # Tenant-scoped application APIs
/api/[industry]/ai/*            # AI/MCP endpoints per industry
/api/admin/v1/*                 # Cross-industry admin APIs
/api/partner/v1/*               # Partner/integration APIs
/api/webhooks/*                 # Inbound webhook handlers
```

## Public Truth Layer APIs

### Standard Public Endpoints (Per Industry)
```tsx
// ✅ Good - Home Services public API
// /apps/hs/src/app/api/public/v1/businesses/[slug]/route.ts
export async function GET(
  request: Request,
  { params }: { params: { slug: string } }
) {
  const business = await getPublicHSBusiness(params.slug)
  
  if (!business) {
    return NextResponse.json(
      { error: 'Business not found' },
      { status: 404 }
    )
  }
  
  return NextResponse.json({
    slug: business.slug,
    name: business.name,
    services: business.services,
    availability: business.publicAvailability,
    reviews: business.publicReviews,
    // Only public data, no internal details
  })
}

// /apps/rest/src/app/api/public/v1/restaurants/[slug]/route.ts
export async function GET(
  request: Request,
  { params }: { params: { slug: string } }
) {
  const restaurant = await getPublicRestaurant(params.slug)
  
  return NextResponse.json({
    slug: restaurant.slug,
    name: restaurant.name,
    cuisine: restaurant.cuisine,
    hours: restaurant.publicHours,
    menu: restaurant.publicMenu,
    reservationWindows: restaurant.availableSlots
  })
}
```

### Booking/Hold Endpoints
```tsx
// ✅ Good - Industry-specific booking holds
// /apps/hs/src/app/api/public/v1/bookings/hold/route.ts
export async function POST(request: Request) {
  const body = await request.json()
  const parsed = hsBookingHoldSchema.parse(body)
  
  const hold = await createHSBookingHold({
    businessSlug: parsed.businessSlug,
    serviceCode: parsed.serviceCode,
    requestedTime: parsed.when,
    customerInfo: parsed.customer,
    address: parsed.address
  })
  
  return NextResponse.json({
    holdId: hold.id,
    expiresAt: hold.expiresAt,
    confirmUrl: `${baseUrl}/hs/confirm/booking/${hold.id}`,
    estimatedDuration: hold.estimatedDuration,
    estimatedPrice: hold.priceRange
  })
}

// /apps/rest/src/app/api/public/v1/reservations/hold/route.ts
export async function POST(request: Request) {
  const body = await request.json()
  const parsed = restReservationHoldSchema.parse(body)
  
  const hold = await createRestaurantReservationHold({
    restaurantSlug: parsed.restaurantSlug,
    partySize: parsed.partySize,
    requestedTime: parsed.when,
    customerInfo: parsed.customer,
    specialRequests: parsed.requests
  })
  
  return NextResponse.json({
    holdId: hold.id,
    expiresAt: hold.expiresAt,
    confirmUrl: `${baseUrl}/rest/confirm/reservation/${hold.id}`,
    tableAssignment: hold.suggestedTable
  })
}
```

## Application APIs (Tenant-Scoped)

### Standard CRUD Patterns
```tsx
// ✅ Good - Industry-specific app API with tenant scoping
// /apps/hs/src/app/api/app/v1/work-orders/route.ts
export async function GET(request: Request) {
  const session = await getHSSession(request)
  const tenant = session.tenantId
  
  const url = new URL(request.url)
  const filters = {
    status: url.searchParams.get('status'),
    technician: url.searchParams.get('technician'),
    date: url.searchParams.get('date'),
    priority: url.searchParams.get('priority')
  }
  
  const workOrders = await hsDb.workOrders.findMany({
    where: {
      tenantId: tenant,
      ...buildHSWorkOrderFilters(filters)
    },
    include: {
      customer: true,
      technician: true,
      lineItems: true
    }
  })
  
  return NextResponse.json({
    data: workOrders,
    meta: {
      total: workOrders.length,
      filters: filters
    }
  })
}

export async function POST(request: Request) {
  const session = await getHSSession(request)
  const tenant = session.tenantId
  const body = await request.json()
  
  // Idempotency key required for all POSTs
  const idempotencyKey = request.headers.get('Idempotency-Key')
  if (!idempotencyKey) {
    return NextResponse.json(
      { error: 'IDEMPOTENCY_KEY_REQUIRED' },
      { status: 400 }
    )
  }
  
  const parsed = hsWorkOrderCreateSchema.parse(body)
  
  const workOrder = await hsDb.workOrders.create({
    data: {
      ...parsed,
      tenantId: tenant,
      createdBy: session.userId,
      idempotencyKey
    }
  })
  
  return NextResponse.json(workOrder, { status: 201 })
}
```

### Resource-Specific Endpoints
```tsx
// ✅ Good - Industry-specific resource operations
// /apps/hs/src/app/api/app/v1/work-orders/[woId]/route.ts
export async function GET(
  request: Request,
  { params }: { params: { woId: string } }
) {
  const session = await getHSSession(request)
  const workOrder = await hsDb.workOrders.findFirst({
    where: {
      id: params.woId,
      tenantId: session.tenantId
    },
    include: {
      customer: true,
      technician: true,
      lineItems: true,
      photos: true,
      notes: true
    }
  })
  
  if (!workOrder) {
    return NextResponse.json(
      { error: 'WORK_ORDER_NOT_FOUND' },
      { status: 404 }
    )
  }
  
  return NextResponse.json(workOrder)
}

// Action endpoints
// /apps/hs/src/app/api/app/v1/work-orders/[woId]/assign/route.ts
export async function POST(
  request: Request,
  { params }: { params: { woId: string } }
) {
  const session = await getHSSession(request)
  const { technicianId } = await request.json()
  
  // Role check for assignment
  if (!session.roles.includes('dispatcher') && !session.roles.includes('manager')) {
    return NextResponse.json(
      { error: 'INSUFFICIENT_PERMISSIONS' },
      { status: 403 }
    )
  }
  
  const workOrder = await hsDb.workOrders.update({
    where: {
      id: params.woId,
      tenantId: session.tenantId
    },
    data: {
      technicianId,
      assignedAt: new Date(),
      assignedBy: session.userId,
      status: 'assigned'
    }
  })
  
  // Trigger notifications
  await notifyTechnicianAssignment(workOrder)
  
  return NextResponse.json(workOrder)
}
```

### Restaurant-Specific API Examples
```tsx
// ✅ Good - Restaurant POS API
// /apps/rest/src/app/api/app/v1/pos/orders/route.ts
export async function POST(request: Request) {
  const session = await getRestaurantSession(request)
  const body = await request.json()
  const parsed = restaurantOrderSchema.parse(body)
  
  const order = await restDb.orders.create({
    data: {
      ...parsed,
      tenantId: session.tenantId,
      serverId: session.userId,
      tableId: parsed.tableId,
      items: {
        create: parsed.items.map(item => ({
          menuItemId: item.menuItemId,
          quantity: item.quantity,
          modifications: item.modifications,
          price: item.price
        }))
      }
    }
  })
  
  // Send to KDS
  await sendToKitchen(order)
  
  return NextResponse.json(order, { status: 201 })
}

// /apps/rest/src/app/api/app/v1/kds/tickets/route.ts
export async function GET(request: Request) {
  const session = await getRestaurantSession(request)
  
  const tickets = await restDb.kitchenTickets.findMany({
    where: {
      tenantId: session.tenantId,
      status: { in: ['new', 'preparing'] }
    },
    include: {
      order: {
        include: {
          items: {
            include: {
              menuItem: true
            }
          }
        }
      }
    },
    orderBy: {
      createdAt: 'asc'
    }
  })
  
  return NextResponse.json(tickets)
}
```

## Error Handling Standards

### Consistent Error Response Format
```tsx
// ✅ Good - Standardized error responses across all APIs
export enum ApiErrorCode {
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  AUTH_ERROR = 'AUTH_ERROR',
  RATE_LIMIT = 'RATE_LIMIT',
  SCHEMA_MISSING = 'SCHEMA_MISSING',
  CONFLICT = 'CONFLICT',
  NOT_FOUND = 'NOT_FOUND',
  DEPENDENCY_DOWN = 'DEPENDENCY_DOWN',
  INSUFFICIENT_PERMISSIONS = 'INSUFFICIENT_PERMISSIONS',
  UNKNOWN = 'UNKNOWN'
}

export function createApiError(
  code: ApiErrorCode,
  message: string,
  details?: any
) {
  return NextResponse.json({
    error: {
      code,
      message,
      details,
      timestamp: new Date().toISOString()
    }
  }, {
    status: getStatusForErrorCode(code)
  })
}

// Usage in endpoints
export async function POST(request: Request) {
  try {
    const body = await request.json()
    const parsed = schema.parse(body)
    // ... business logic
  } catch (error) {
    if (error instanceof z.ZodError) {
      return createApiError(
        ApiErrorCode.VALIDATION_ERROR,
        'Invalid request data',
        error.errors
      )
    }
    
    return createApiError(
      ApiErrorCode.UNKNOWN,
      'An unexpected error occurred'
    )
  }
}
```

## Idempotency Implementation

### Idempotency Key Handling
```tsx
// ✅ Good - Consistent idempotency across all POST endpoints
export async function handleIdempotentRequest<T>(
  request: Request,
  tenantId: string,
  operation: () => Promise<T>
): Promise<NextResponse> {
  const idempotencyKey = request.headers.get('Idempotency-Key')
  
  if (!idempotencyKey) {
    return createApiError(
      ApiErrorCode.VALIDATION_ERROR,
      'Idempotency-Key header is required for POST requests'
    )
  }
  
  // Check for existing request
  const existing = await db.idempotencyKeys.findUnique({
    where: {
      key: idempotencyKey,
      tenantId
    }
  })
  
  if (existing) {
    if (existing.status === 'completed') {
      return NextResponse.json(existing.response, {
        status: existing.statusCode
      })
    } else {
      return createApiError(
        ApiErrorCode.CONFLICT,
        'Request is already being processed'
      )
    }
  }
  
  // Create idempotency record
  await db.idempotencyKeys.create({
    data: {
      key: idempotencyKey,
      tenantId,
      status: 'processing',
      createdAt: new Date()
    }
  })
  
  try {
    const result = await operation()
    
    // Update idempotency record with result
    await db.idempotencyKeys.update({
      where: { key: idempotencyKey },
      data: {
        status: 'completed',
        response: result,
        statusCode: 201,
        completedAt: new Date()
      }
    })
    
    return NextResponse.json(result, { status: 201 })
  } catch (error) {
    // Update idempotency record with error
    await db.idempotencyKeys.update({
      where: { key: idempotencyKey },
      data: {
        status: 'failed',
        error: error.message,
        completedAt: new Date()
      }
    })
    
    throw error
  }
}
```

## API Client Generation

### Industry-Specific Client Generation
```tsx
// ✅ Good - Generated API clients per industry
// /packages/api-client/hs/index.ts
export class HSApiClient {
  constructor(
    private baseUrl: string,
    private tenantId: string,
    private apiKey?: string
  ) {}
  
  async workOrders() {
    return new HSWorkOrdersAPI(this.baseUrl, this.tenantId, this.apiKey)
  }
  
  async estimates() {
    return new HSEstimatesAPI(this.baseUrl, this.tenantId, this.apiKey)
  }
  
  async invoices() {
    return new HSInvoicesAPI(this.baseUrl, this.tenantId, this.apiKey)
  }
}

// /packages/api-client/rest/index.ts  
export class RestaurantApiClient {
  constructor(
    private baseUrl: string,
    private tenantId: string,
    private apiKey?: string
  ) {}
  
  async pos() {
    return new RestaurantPOSAPI(this.baseUrl, this.tenantId, this.apiKey)
  }
  
  async kds() {
    return new RestaurantKDSAPI(this.baseUrl, this.tenantId, this.apiKey)
  }
  
  async checks() {
    return new RestaurantChecksAPI(this.baseUrl, this.tenantId, this.apiKey)
  }
}
```

### Client Usage Patterns
```tsx
// ✅ Good - Industry-specific client usage
// In Home Services app
import { hsApiClient } from '@/lib/api-client'

export async function createWorkOrder(data: CreateWorkOrderData) {
  return await hsApiClient.workOrders.create(data, {
    idempotencyKey: generateIdempotencyKey()
  })
}

// In Restaurant app
import { restApiClient } from '@/lib/api-client'

export async function createOrder(data: CreateOrderData) {
  return await restApiClient.pos.createOrder(data, {
    idempotencyKey: generateIdempotencyKey()
  })
}

// ❌ Bad - Cross-industry client usage
import { hsApiClient } from '@/lib/api-client'
// In restaurant app trying to use HS client - forbidden
```

## OpenAPI Documentation

### Industry-Specific OpenAPI Specs
```tsx
// ✅ Good - Separate OpenAPI specs per industry
// /apps/hs/src/app/api/public/v1/openapi.yaml/route.ts
export async function GET() {
  const spec = generateHSPublicOpenAPISpec({
    version: 'v1',
    title: 'Thorbis Home Services Public API',
    description: 'Public APIs for Home Services booking and information',
    servers: [
      { url: 'https://api.thorbis.com/hs/public/v1' }
    ]
  })
  
  return new Response(JSON.stringify(spec), {
    headers: {
      'Content-Type': 'application/json',
      'Cache-Control': 's-maxage=3600, stale-while-revalidate=86400'
    }
  })
}

// /apps/rest/src/app/api/public/v1/openapi.yaml/route.ts
export async function GET() {
  const spec = generateRestaurantPublicOpenAPISpec({
    version: 'v1', 
    title: 'Thorbis Restaurant Public API',
    description: 'Public APIs for restaurant reservations and information'
  })
  
  return new Response(JSON.stringify(spec), {
    headers: {
      'Content-Type': 'application/json',
      'Cache-Control': 's-maxage=3600, stale-while-revalidate=86400'
    }
  })
}
```

## API Testing Patterns

### Industry-Specific API Tests
```tsx
// ✅ Good - Industry-isolated API tests
describe('HS Work Orders API', () => {
  beforeEach(async () => {
    await setupHSTestTenant()
    await seedHSTestData()
  })
  
  describe('POST /api/hs/app/v1/work-orders', () => {
    it('should create work order for dispatcher role', async () => {
      const response = await request(app)
        .post('/api/hs/app/v1/work-orders')
        .set('Authorization', `Bearer ${hsDispatcherToken}`)
        .set('Idempotency-Key', uuid())
        .send(validHSWorkOrderData)
        
      expect(response.status).toBe(201)
      expect(response.body).toHaveProperty('id')
      expect(response.body.status).toBe('created')
    })
    
    it('should reject work order creation for technician role', async () => {
      const response = await request(app)
        .post('/api/hs/app/v1/work-orders')
        .set('Authorization', `Bearer ${hsTechnicianToken}`)
        .set('Idempotency-Key', uuid())
        .send(validHSWorkOrderData)
        
      expect(response.status).toBe(403)
      expect(response.body.error.code).toBe('INSUFFICIENT_PERMISSIONS')
    })
  })
})

// Separate test suite for restaurant APIs
describe('Restaurant Orders API', () => {
  // Restaurant-specific API tests
})
```