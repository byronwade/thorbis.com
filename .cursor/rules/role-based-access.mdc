---
globs: **/middleware.ts,**/auth/**,**/permissions/**,**/*rbac*
description: Role-based access control patterns and implementation for industry-specific permissions
---

# Thorbis Role-Based Access Control (RBAC)

## Core RBAC Principles

### Industry-Specific Role Systems
- **Each industry has unique roles**: No shared role definitions across industries
- **Industry-scoped permissions**: Roles mean different things in different contexts
- **Granular resource access**: Fine-grained permissions for each resource type
- **Tenant isolation**: Roles and permissions are scoped to specific tenants

### Role Hierarchy Standards

#### Home Services Roles
```tsx
export enum HSRole {
  OWNER = 'owner',           // Full access to everything
  MANAGER = 'manager',       // Operations management
  DISPATCHER = 'dispatcher', // Scheduling and dispatch
  CSR = 'csr',              // Customer service rep
  TECHNICIAN = 'technician', // Field work
  ACCOUNTANT = 'accountant', // Financial access
  VIEWER = 'viewer',         // Read-only access
  API_PARTNER = 'api_partner' // External API access
}

export const hsRoleHierarchy = {
  [HSRole.OWNER]: [
    'hs.workorders.*', 'hs.estimates.*', 'hs.invoices.*',
    'hs.customers.*', 'hs.dispatch.*', 'hs.accounting.*',
    'hs.settings.*', 'hs.reports.*', 'hs.users.*'
  ],
  [HSRole.MANAGER]: [
    'hs.workorders.*', 'hs.estimates.*', 'hs.invoices.*',
    'hs.customers.*', 'hs.dispatch.*', 'hs.reports.read'
  ],
  [HSRole.DISPATCHER]: [
    'hs.workorders.read', 'hs.workorders.assign', 'hs.workorders.update',
    'hs.dispatch.*', 'hs.customers.read', 'hs.technicians.read'
  ],
  [HSRole.TECHNICIAN]: [
    'hs.workorders.read', 'hs.workorders.update_own',
    'hs.customers.read', 'hs.photos.create', 'hs.notes.create'
  ],
  [HSRole.CSR]: [
    'hs.customers.*', 'hs.estimates.create', 'hs.estimates.read',
    'hs.bookings.create', 'hs.workorders.create'
  ]
}
```

#### Restaurant Roles
```tsx
export enum RestaurantRole {
  OWNER = 'owner',
  GM = 'gm',                    // General Manager
  SHIFT_MANAGER = 'shift_manager',
  SERVER = 'server',
  BARTENDER = 'bartender',
  HOST = 'host',
  KITCHEN = 'kitchen',
  INVENTORY_MANAGER = 'inventory_manager',
  ACCOUNTANT = 'accountant'
}

export const restaurantRoleHierarchy = {
  [RestaurantRole.OWNER]: [
    'rest.pos.*', 'rest.kds.*', 'rest.checks.*', 'rest.menus.*',
    'rest.inventory.*', 'rest.staff.*', 'rest.accounting.*', 'rest.settings.*'
  ],
  [RestaurantRole.SERVER]: [
    'rest.pos.read', 'rest.pos.create_order', 'rest.checks.*',
    'rest.tables.read', 'rest.customers.read'
  ],
  [RestaurantRole.KITCHEN]: [
    'rest.kds.*', 'rest.recipes.read', 'rest.inventory.read'
  ],
  [RestaurantRole.HOST]: [
    'rest.reservations.*', 'rest.tables.read', 'rest.tables.assign',
    'rest.customers.read'
  ]
}
```

#### Auto Services Roles
```tsx
export enum AutoRole {
  OWNER = 'owner',
  SERVICE_WRITER = 'service_writer',
  ESTIMATOR = 'estimator',
  TECHNICIAN = 'technician',
  PARTS_MANAGER = 'parts_manager',
  CASHIER = 'cashier',
  ACCOUNTANT = 'accountant'
}
```

#### Retail Roles
```tsx
export enum RetailRole {
  OWNER = 'owner',
  STORE_MANAGER = 'store_manager',
  CASHIER = 'cashier',
  BUYER = 'buyer',
  STOCKER = 'stocker',
  ACCOUNTANT = 'accountant'
}
```

## Permission Implementation

### Industry-Specific Permission Checking
```tsx
// ✅ Good - Industry-aware permission system
export class HSPermissionChecker {
  constructor(
    private userId: string,
    private tenantId: string,
    private roles: HSRole[]
  ) {}
  
  can(permission: string): boolean {
    return this.roles.some(role => {
      const rolePermissions = hsRoleHierarchy[role] || []
      return rolePermissions.some(p => this.matchesPermission(p, permission))
    })
  }
  
  canAccessWorkOrder(workOrderId: string, action: 'read' | 'update' | 'assign'): boolean {
    switch (action) {
      case 'read':
        return this.can('hs.workorders.read')
      case 'update':
        // Technicians can only update their own work orders
        if (this.roles.includes(HSRole.TECHNICIAN)) {
          return this.canUpdateOwnWorkOrder(workOrderId)
        }
        return this.can('hs.workorders.update')
      case 'assign':
        return this.can('hs.workorders.assign')
      default:
        return false
    }
  }
  
  private canUpdateOwnWorkOrder(workOrderId: string): boolean {
    // Check if technician is assigned to this work order
    return this.can('hs.workorders.update_own')
  }
  
  private matchesPermission(rolePermission: string, requestedPermission: string): boolean {
    // Handle wildcard permissions
    if (rolePermission.endsWith('*')) {
      const prefix = rolePermission.slice(0, -1)
      return requestedPermission.startsWith(prefix)
    }
    return rolePermission === requestedPermission
  }
}

// Restaurant permission checker (different logic)
export class RestaurantPermissionChecker {
  constructor(
    private userId: string,
    private tenantId: string,
    private roles: RestaurantRole[]
  ) {}
  
  canAccessTable(tableId: string, action: 'read' | 'assign' | 'serve'): boolean {
    switch (action) {
      case 'read':
        return this.can('rest.tables.read')
      case 'assign':
        return this.roles.includes(RestaurantRole.HOST) || 
               this.roles.includes(RestaurantRole.SHIFT_MANAGER)
      case 'serve':
        return this.roles.includes(RestaurantRole.SERVER) ||
               this.roles.includes(RestaurantRole.BARTENDER)
      default:
        return false
    }
  }
  
  canProcessPayment(amount: number): boolean {
    // Different payment limits based on role
    if (this.roles.includes(RestaurantRole.SHIFT_MANAGER)) {
      return true // No limit
    }
    if (this.roles.includes(RestaurantRole.SERVER)) {
      return amount <= 500 // $500 limit for servers
    }
    return false
  }
}
```

### Middleware-Based Route Protection
```tsx
// ✅ Good - Industry-specific middleware with role checking
// /apps/hs/src/middleware.ts
export function middleware(request: NextRequest) {
  const pathname = request.nextUrl.pathname
  
  // Only protect HS app routes
  if (!pathname.startsWith('/hs/app')) {
    return NextResponse.next()
  }
  
  return withHSRoleProtection(request, pathname)
}

async function withHSRoleProtection(
  request: NextRequest, 
  pathname: string
): Promise<NextResponse> {
  const session = await getHSSession(request)
  
  if (!session) {
    return NextResponse.redirect(new URL('/login', request.url))
  }
  
  const permissions = new HSPermissionChecker(
    session.userId,
    session.tenantId,
    session.roles
  )
  
  // Route-specific permission checks
  if (pathname.startsWith('/hs/app/dispatch')) {
    if (!permissions.can('hs.dispatch.read')) {
      return NextResponse.redirect(new URL('/hs/app', request.url))
    }
  }
  
  if (pathname.startsWith('/hs/app/accounting')) {
    if (!permissions.can('hs.accounting.read')) {
      return NextResponse.redirect(new URL('/hs/app', request.url))
    }
  }
  
  if (pathname.startsWith('/hs/app/settings')) {
    if (!permissions.can('hs.settings.read')) {
      return NextResponse.redirect(new URL('/hs/app', request.url))
    }
  }
  
  // Add role info to request headers for downstream use
  const requestHeaders = new Headers(request.headers)
  requestHeaders.set('x-hs-roles', JSON.stringify(session.roles))
  requestHeaders.set('x-hs-tenant', session.tenantId)
  requestHeaders.set('x-hs-user', session.userId)
  
  return NextResponse.next({
    request: {
      headers: requestHeaders
    }
  })
}
```

### API-Level Permission Enforcement
```tsx
// ✅ Good - Permission checks in API endpoints
// /apps/hs/src/app/api/app/v1/work-orders/[woId]/assign/route.ts
export async function POST(
  request: Request,
  { params }: { params: { woId: string } }
) {
  const session = await getHSSession(request)
  const permissions = new HSPermissionChecker(
    session.userId,
    session.tenantId,
    session.roles
  )
  
  // Check permission to assign work orders
  if (!permissions.canAccessWorkOrder(params.woId, 'assign')) {
    return NextResponse.json(
      { 
        error: {
          code: 'INSUFFICIENT_PERMISSIONS',
          message: 'You do not have permission to assign work orders',
          requiredPermissions: ['hs.workorders.assign']
        }
      },
      { status: 403 }
    )
  }
  
  const { technicianId } = await request.json()
  
  // Business logic for assignment
  const workOrder = await hsDb.workOrders.update({
    where: {
      id: params.woId,
      tenantId: session.tenantId
    },
    data: {
      technicianId,
      assignedAt: new Date(),
      assignedBy: session.userId,
      status: 'assigned'
    }
  })
  
  return NextResponse.json(workOrder)
}
```

## Frontend Permission Components

### Role-Based UI Rendering
```tsx
// ✅ Good - Industry-specific permission components
export function HSPermissionGate({ 
  permission,
  workOrderId,
  children,
  fallback 
}: {
  permission: string
  workOrderId?: string
  children: React.ReactNode
  fallback?: React.ReactNode
}) {
  const { session } = useHSAuth()
  const permissions = useMemo(() => 
    new HSPermissionChecker(
      session.userId,
      session.tenantId,
      session.roles
    ), [session]
  )
  
  const canAccess = workOrderId 
    ? permissions.canAccessWorkOrder(workOrderId, permission as any)
    : permissions.can(permission)
  
  if (!canAccess) {
    return <>{fallback}</>
  }
  
  return <>{children}</>
}

// Usage in HS components
export function WorkOrderActions({ workOrder }) {
  return (
    <div className="flex gap-2">
      <HSPermissionGate permission="hs.workorders.update">
        <Button onClick={() => editWorkOrder(workOrder.id)}>
          Edit
        </Button>
      </HSPermissionGate>
      
      <HSPermissionGate 
        permission="assign" 
        workOrderId={workOrder.id}
        fallback={
          <Tooltip content="Only dispatchers can assign work orders">
            <Button disabled>Assign</Button>
          </Tooltip>
        }
      >
        <Button onClick={() => showAssignmentDialog(workOrder.id)}>
          Assign Technician
        </Button>
      </HSPermissionGate>
    </div>
  )
}

// Restaurant equivalent
export function RestaurantPermissionGate({
  permission,
  tableId,
  children,
  fallback
}: {
  permission: string
  tableId?: string
  children: React.ReactNode
  fallback?: React.ReactNode
}) {
  const { session } = useRestaurantAuth()
  const permissions = new RestaurantPermissionChecker(
    session.userId,
    session.tenantId,
    session.roles
  )
  
  const canAccess = tableId
    ? permissions.canAccessTable(tableId, permission as any)
    : permissions.can(permission)
  
  return canAccess ? <>{children}</> : <>{fallback}</>
}
```

### Dynamic Navigation Based on Roles
```tsx
// ✅ Good - Role-based navigation menu
export function HSNavigationMenu() {
  const { session } = useHSAuth()
  const permissions = new HSPermissionChecker(
    session.userId,
    session.tenantId,
    session.roles
  )
  
  const navigationItems = useMemo(() => {
    const items = [
      { 
        label: 'Dashboard', 
        href: '/hs/app',
        icon: Home,
        permission: 'hs.dashboard.read'
      }
    ]
    
    if (permissions.can('hs.dispatch.read')) {
      items.push({
        label: 'Dispatch',
        href: '/hs/app/dispatch',
        icon: Dispatch,
        permission: 'hs.dispatch.read'
      })
    }
    
    if (permissions.can('hs.workorders.read')) {
      items.push({
        label: 'Work Orders',
        href: '/hs/app/work-orders',
        icon: Wrench,
        permission: 'hs.workorders.read'
      })
    }
    
    if (permissions.can('hs.estimates.read')) {
      items.push({
        label: 'Estimates',
        href: '/hs/app/estimates',
        icon: Calculator,
        permission: 'hs.estimates.read'
      })
    }
    
    if (permissions.can('hs.accounting.read')) {
      items.push({
        label: 'Accounting',
        href: '/hs/app/accounting',
        icon: DollarSign,
        permission: 'hs.accounting.read'
      })
    }
    
    if (permissions.can('hs.settings.read')) {
      items.push({
        label: 'Settings',
        href: '/hs/app/settings',
        icon: Settings,
        permission: 'hs.settings.read'
      })
    }
    
    return items
  }, [permissions])
  
  return (
    <nav className="space-y-2">
      {navigationItems.map(item => (
        <NavigationLink
          key={item.href}
          href={item.href}
          icon={item.icon}
          prefetch="auto"
        >
          {item.label}
        </NavigationLink>
      ))}
    </nav>
  )
}
```

## Role Management & Assignment

### Industry-Specific Role Assignment
```tsx
// ✅ Good - Industry role management
export function HSRoleManagement({ tenantId }: { tenantId: string }) {
  const [users, setUsers] = useState<HSUser[]>([])
  
  const availableRoles = [
    { 
      value: HSRole.OWNER, 
      label: 'Owner',
      description: 'Full access to all features and settings'
    },
    { 
      value: HSRole.MANAGER, 
      label: 'Manager',
      description: 'Manage operations, view reports, assign work'
    },
    { 
      value: HSRole.DISPATCHER, 
      label: 'Dispatcher',
      description: 'Schedule and assign work orders to technicians'
    },
    { 
      value: HSRole.TECHNICIAN, 
      label: 'Technician',
      description: 'Complete assigned work orders, upload photos'
    },
    { 
      value: HSRole.CSR, 
      label: 'Customer Service Rep',
      description: 'Handle customer inquiries, create estimates'
    }
  ]
  
  const updateUserRoles = async (userId: string, roles: HSRole[]) => {
    await hsApiClient.users.updateRoles(userId, {
      roles,
      tenantId
    })
  }
  
  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-xl font-semibold mb-4">User Roles & Permissions</h2>
        <p className="text-gray-600 mb-6">
          Manage access levels for your Home Services team members.
        </p>
      </div>
      
      <div className="space-y-4">
        {users.map(user => (
          <div key={user.id} className="bg-white border rounded-lg p-6">
            <div className="flex items-center justify-between mb-4">
              <div>
                <h3 className="font-medium">{user.name}</h3>
                <p className="text-sm text-gray-500">{user.email}</p>
              </div>
              <div className="flex flex-wrap gap-2">
                {user.roles.map(role => (
                  <Badge key={role} variant="secondary">
                    {role}
                  </Badge>
                ))}
              </div>
            </div>
            
            <HSRoleSelector
              currentRoles={user.roles}
              availableRoles={availableRoles}
              onRolesChange={(roles) => updateUserRoles(user.id, roles)}
            />
          </div>
        ))}
      </div>
    </div>
  )
}
```

## Testing Role-Based Access

### Permission Testing Patterns
```tsx
// ✅ Good - Comprehensive RBAC testing
describe('HS Role-Based Access Control', () => {
  describe('HSPermissionChecker', () => {
    it('should allow dispatcher to assign work orders', () => {
      const permissions = new HSPermissionChecker(
        'user-1',
        'tenant-1',
        [HSRole.DISPATCHER]
      )
      
      expect(permissions.canAccessWorkOrder('wo-1', 'assign')).toBe(true)
    })
    
    it('should prevent technician from assigning work orders', () => {
      const permissions = new HSPermissionChecker(
        'user-2',
        'tenant-1',
        [HSRole.TECHNICIAN]
      )
      
      expect(permissions.canAccessWorkOrder('wo-1', 'assign')).toBe(false)
    })
    
    it('should allow technician to update own work orders', () => {
      const permissions = new HSPermissionChecker(
        'tech-1',
        'tenant-1',
        [HSRole.TECHNICIAN]
      )
      
      // Mock that technician is assigned to this work order
      jest.spyOn(permissions as any, 'canUpdateOwnWorkOrder').mockReturnValue(true)
      
      expect(permissions.canAccessWorkOrder('wo-tech-1', 'update')).toBe(true)
    })
  })
  
  describe('API Permission Enforcement', () => {
    it('should reject work order assignment from technician', async () => {
      const response = await request(app)
        .post('/api/hs/app/v1/work-orders/wo-1/assign')
        .set('Authorization', `Bearer ${technicianToken}`)
        .send({ technicianId: 'tech-2' })
        
      expect(response.status).toBe(403)
      expect(response.body.error.code).toBe('INSUFFICIENT_PERMISSIONS')
    })
    
    it('should allow work order assignment from dispatcher', async () => {
      const response = await request(app)
        .post('/api/hs/app/v1/work-orders/wo-1/assign')
        .set('Authorization', `Bearer ${dispatcherToken}`)
        .send({ technicianId: 'tech-2' })
        
      expect(response.status).toBe(200)
    })
  })
})
```