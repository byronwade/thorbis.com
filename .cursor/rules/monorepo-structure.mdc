---
alwaysApply: true
---

# Thorbis Monorepo Structure & Organization Rules

## Core Architecture Principles

### Industry Separation (Critical)
- **No shared sales documents**: Each industry (HS/REST/AUTO/RET) has independent invoices, estimates, receipts
- **Independent apps**: Each industry app is self-contained for focus and speed
- **Shared primitives only**: Design tokens, base components, auth, billing
- **Industry-specific schemas**: Keep data shapes separate in `/packages/schemas/`

### Monorepo Topology (Canonical)

```
/apps
  /site              ← Marketing/Docs (multi-industry)
  /hs                ← Home Services app 
  /rest              ← Restaurants app
  /auto              ← Auto Services app
  /ret               ← Retail app
  /admin             ← Internal admin console
  /partner           ← Partner portal

/packages
  /ui                ← shadcn-based components (overlay-free variants)
  /design            ← Tokens, themes (dark-first), density modes
  /schemas           ← Separate schemas per industry (hs/rest/auto/ret)
  /api-client        ← Generated SDKs per namespace with idempotency
  /auth              ← Shared authentication
  /billing           ← Usage meters + Stripe client
  /agent             ← MCP server, AI policies per industry
```

## File Organization Standards

### App-Level Structure
```tsx
// ✅ Good - Industry-specific app structure
/apps/hs/src/app/
  ├── (auth)/          // Auth layouts
  ├── app/             // Main app routes
  │   ├── dispatch/
  │   ├── work-orders/
  │   ├── estimates/   // HS-specific, not shared
  │   └── invoices/    // HS-specific, not shared
  ├── api/             // HS-specific API routes
  └── globals.css

// ❌ Bad - Shared sales document structure
/apps/shared/invoices/  // Never share across industries
```

### Package Organization
```tsx
// ✅ Good - Industry-separated schemas
/packages/schemas/
  ├── hs/              // Home Services types
  │   ├── work-order.ts
  │   ├── estimate.ts
  │   └── invoice.ts
  ├── rest/            // Restaurant types
  │   ├── check.ts
  │   ├── menu.ts
  │   └── vendor-invoice.ts
  ├── auto/            // Auto Services types
  └── ret/             // Retail types

// ✅ Good - Shared primitives
/packages/ui/
  ├── components/      // Base shadcn components
  ├── overlay-free/    // Inline variants (no modals)
  └── industry/        // Industry-specific compound components
```

## Import Patterns & Dependencies

### Cross-Package Imports
```tsx
// ✅ Good - Clear industry boundaries
import { HSWorkOrder } from '@repo/schemas/hs'
import { RestaurantCheck } from '@repo/schemas/rest'
import { InlineConfirmBar } from '@repo/ui/overlay-free'
import { ThorbisButton } from '@repo/ui/components'

// ❌ Bad - Cross-industry contamination
import { RestaurantCheck } from '@repo/schemas/hs' // Wrong industry
import { Dialog } from '@repo/ui/components' // Overlay component
```

### Internal App Imports
```tsx
// ✅ Good - App-relative imports within industry
import { HSEstimateForm } from '@/components/estimates/estimate-form'
import { WorkOrderActions } from '@/components/work-orders/actions'
import { hsApiClient } from '@/lib/api-client'

// ❌ Bad - Absolute imports for app internals
import { HSEstimateForm } from '@repo/hs/components/estimates/estimate-form'
```

## Code Sharing Guidelines (Favor Component Reuse)

### ALWAYS Share & Reuse
- **All UI components**: DataTable, Forms, Buttons, Modals, Cards, etc.
- **Layout components**: Headers, Sidebars, Containers
- **Interactive patterns**: Filters, Search, Pagination, Actions
- **Design tokens**: Colors, spacing, typography
- **Authentication**: Login, session management
- **Utilities**: Date formatting, validation, helpers

### NEVER Share
- **Data schemas**: Keep separate for each industry
- **API endpoints**: Industry-namespaced routes
- **Business logic**: Industry-specific workflows
- **Database tables**: Industry-prefixed tables only

### Component Reuse Strategy
```tsx
// ✅ PREFERRED - Reuse existing DataTable across all industries
export function DataTable({ 
  data, 
  columns,
  filters,
  actions,
  onRowClick,
  emptyState,
  ...props 
}) {
  return (
    <div className="space-y-4">
      <DataTableFilters filters={filters} />
      <Table {...props}>
        <TableHeader>
          {columns.map(column => (
            <TableHead key={column.key}>
              {column.label}
            </TableHead>
          ))}
        </TableHeader>
        <TableBody>
          {data.map(row => (
            <TableRow key={row.id} onClick={() => onRowClick?.(row)}>
              {columns.map(column => (
                <TableCell key={column.key}>
                  {column.render ? column.render(row) : row[column.key]}
                </TableCell>
              ))}
            </TableRow>
          ))}
        </TableBody>
      </Table>
      {actions && <DataTableActions actions={actions} />}
    </div>
  )
}

// ✅ GOOD - Same component used across industries with different data
export function HSWorkOrdersTable({ workOrders }) {
  return (
    <DataTable
      data={workOrders}
      columns={workOrderColumns}
      onRowClick={(workOrder) => router.push(`/hs/app/work-orders/${workOrder.id}`)}
      emptyState="No work orders found"
    />
  )
}

export function RestaurantChecksTable({ checks }) {
  return (
    <DataTable
      data={checks}
      columns={checkColumns} // Different columns, same component
      onRowClick={(check) => router.push(`/rest/app/checks/${check.id}`)}
      emptyState="No checks found"
    />
  )
}

export function RetailOrdersTable({ orders }) {
  return (
    <DataTable
      data={orders}
      columns={orderColumns} // Different columns, same component
      onRowClick={(order) => router.push(`/ret/app/orders/${order.id}`)}
      emptyState="No orders found"
    />
  )
}

// ❌ AVOID - Creating separate table components per industry
export function HSWorkOrderTable() { /* Custom implementation */ }
export function RestaurantCheckTable() { /* Duplicate implementation */ }
export function RetailOrderTable() { /* Another duplicate */ }
```

### Extending Existing Components (When Needed)
```tsx
// ✅ GOOD - Extend existing component with industry-specific features
export function DataTableWithBulkActions({ 
  data, 
  columns,
  bulkActions,
  ...tableProps 
}) {
  const [selectedItems, setSelectedItems] = useState([])
  
  return (
    <div>
      {selectedItems.length > 0 && (
        <BulkActionsBar 
          selectedItems={selectedItems}
          actions={bulkActions}
          onClear={() => setSelectedItems([])}
        />
      )}
      <DataTable
        data={data}
        columns={[
          {
            key: 'select',
            render: (row) => (
              <Checkbox
                checked={selectedItems.includes(row.id)}
                onCheckedChange={(checked) => {
                  if (checked) {
                    setSelectedItems(prev => [...prev, row.id])
                  } else {
                    setSelectedItems(prev => prev.filter(id => id !== row.id))
                  }
                }}
              />
            )
          },
          ...columns
        ]}
        {...tableProps}
      />
    </div>
  )
}

// Use the same extended component across industries
export function HSWorkOrdersWithBulk({ workOrders }) {
  return (
    <DataTableWithBulkActions
      data={workOrders}
      columns={workOrderColumns}
      bulkActions={hsBulkActions}
    />
  )
}

export function RestaurantChecksWithBulk({ checks }) {
  return (
    <DataTableWithBulkActions
      data={checks}
      columns={checkColumns}
      bulkActions={restBulkActions}
    />
  )
}
```

## Scalability Patterns

### Feature Flag Organization
```tsx
// ✅ Good - Industry-specific feature flags
const featureFlags = {
  'hs.dispatch.ai-routing': true,
  'rest.pos.tip-suggestions': false,
  'auto.bays.smart-assignment': true,
  'ret.inventory.auto-reorder': false,
  'global.dark-mode': true
}

// Implementation
const flag = useFeatureFlag('hs.dispatch.ai-routing')
```

### API Client Generation
```tsx
// ✅ Good - Industry-namespaced clients
import { hsApiClient } from '@repo/api-client/hs'
import { restApiClient } from '@repo/api-client/rest'

// Each industry gets its own typed client
const workOrders = await hsApiClient.workOrders.list()
const checks = await restApiClient.checks.list()
```

### Database Schema Organization
```sql
-- ✅ Good - Industry-prefixed tables
CREATE TABLE hs_work_orders (...)
CREATE TABLE hs_estimates (...)
CREATE TABLE hs_invoices (...)

CREATE TABLE rest_checks (...)
CREATE TABLE rest_vendor_invoices (...)

CREATE TABLE auto_repair_orders (...)
CREATE TABLE ret_receipts (...)

-- ✅ Good - Shared tables
CREATE TABLE users (...)
CREATE TABLE organizations (...)
CREATE TABLE billing_usage (...)
```

## Development Workflow

### Package Scripts Organization
```json
{
  "scripts": {
    "dev:hs": "turbo run dev --filter=@repo/hs",
    "dev:rest": "turbo run dev --filter=@repo/rest",
    "dev:auto": "turbo run dev --filter=@repo/auto",
    "dev:ret": "turbo run dev --filter=@repo/ret",
    "dev:all": "turbo run dev",
    "build:apps": "turbo run build --filter='./apps/*'",
    "test:hs": "turbo run test --filter=@repo/hs",
    "type-check:all": "turbo run type-check"
  }
}
```

### Migration Patterns
```bash
# ✅ Good - Industry-specific migrations
/migrations/
  ├── shared/           # Auth, billing, global
  ├── hs/              # Home Services specific
  ├── rest/            # Restaurant specific  
  ├── auto/            # Auto Services specific
  └── ret/             # Retail specific
```

## Quality Gates

### Pre-commit Checks
- [ ] No cross-industry imports in app code
- [ ] No shared sales document schemas
- [ ] No overlay components imported
- [ ] Industry prefixes on new tables/types
- [ ] Feature flags properly namespaced

### Architecture Reviews
- [ ] New features maintain industry separation
- [ ] Shared code serves all industries equally
- [ ] API endpoints follow namespace conventions
- [ ] Database changes don't break industry isolation
- [ ] UI components are overlay-free