/**
 * Alert Handlers for Billing Monitor
 * Handles different types of billing alerts with appropriate actions
 * Created: 2025-01-31
 */

import { BillingAlert } from './billing-monitor';

export interface AlertHandler {
  type: BillingAlert['type'];
  handle: (alert: BillingAlert) => Promise<void>;
}

export interface EmailConfig {
  apiKey: string;
  fromEmail: string;
  replyTo?: string;
}

export interface SlackConfig {
  webhookUrl: string;
  channel?: string;
}

export interface NotificationConfig {
  email?: EmailConfig;
  slack?: SlackConfig;
  webhooks?: string[];
  sms?: {
    accountSid: string;
    authToken: string;
    fromNumber: string;
  };
}

/**
 * Email notification handler using a generic email service
 */
export class EmailAlertHandler implements AlertHandler {
  type: BillingAlert['type'] = 'usage_threshold';
  
  constructor(private config: EmailConfig) {}

  async handle(alert: BillingAlert): Promise<void> {
    const emailData = {
      to: await this.getOrganizationEmail(alert.organizationId),
      subject: this.getEmailSubject(alert),
      html: this.generateEmailHTML(alert),
      text: this.generateEmailText(alert),
    };

    try {
      // In a real implementation, you would use your email service API
      console.log(`Sending email alert: ${alert.title} to ${emailData.to}`);
      
      // Example with a generic HTTP POST to your email service
      await fetch('/api/send-email', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(emailData),
      });
    } catch (error) {
      console.error('Failed to send email alert:', error);
    }
  }

  private async getOrganizationEmail(organizationId: string): Promise<string> {
    // This would typically query your database for the organization's billing contact
    return 'billing@organization.com';
  }

  private getEmailSubject(alert: BillingAlert): string {
    const severityPrefix = alert.severity === 'critical' ? 'üö® CRITICAL' : 
                          alert.severity === 'high' ? '‚ö†Ô∏è HIGH' :
                          alert.severity === 'medium' ? 'üìä MEDIUM' : '‚ÑπÔ∏è INFO';
    
    return `${severityPrefix}: ${alert.title}`;
  }

  private generateEmailHTML(alert: BillingAlert): string {
    const severityColor = {
      critical: '#dc2626', // red-600
      high: '#ea580c',     // orange-600
      medium: '#d97706',   // amber-600
      low: '#2563eb'       // blue-600
    }[alert.severity];

    return `
      <!DOCTYPE html>
      <html>
        <head>
          <meta charset="utf-8">
          <title>${alert.title}</title>
          <style>
            body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; }
            .header { background: ${severityColor}; color: white; padding: 20px; border-radius: 8px 8px 0 0; }
            .content { background: #f9f9f9; padding: 20px; border-radius: 0 0 8px 8px; border: 1px solid #ddd; }
            .alert-data { background: white; padding: 15px; margin: 15px 0; border-radius: 4px; border-left: 4px solid ${severityColor}; }
            .footer { text-align: center; margin-top: 20px; font-size: 12px; color: #666; }
            .cta-button { display: inline-block; background: ${severityColor}; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; margin: 15px 0; }
          </style>
        </head>
        <body>
          <div class="header">
            <h1>${alert.title}</h1>
            <p>Severity: ${alert.severity.toUpperCase()} | ${alert.createdAt.toLocaleString()}</p>
          </div>
          
          <div class="content">
            <p><strong>Message:</strong></p>
            <p>${alert.message}</p>
            
            ${alert.data ? `
              <div class="alert-data">
                <h3>Alert Details:</h3>
                <pre>${JSON.stringify(alert.data, null, 2)}</pre>
              </div>
            ` : ''}
            
            ${alert.actionRequired ? `
              <p><strong>Action Required:</strong> This alert requires immediate attention.</p>
              <a href="https://thorbis.com/billing" class="cta-button">View Billing Dashboard</a>
            ` : ''}
          </div>
          
          <div class="footer">
            <p>This alert was generated by Thorbis Billing Monitor</p>
            <p>Organization ID: ${alert.organizationId}</p>
          </div>
        </body>
      </html>
    `;
  }

  private generateEmailText(alert: BillingAlert): string {
    return `
BILLING ALERT: ${alert.title}
Severity: ${alert.severity.toUpperCase()}
Time: ${alert.createdAt.toLocaleString()}

Message: ${alert.message}

${alert.data ? `Details:\n${JSON.stringify(alert.data, null, 2)}\n` : ''}

${alert.actionRequired ? 'ACTION REQUIRED: This alert requires immediate attention.\n' : ''}

View your billing dashboard: https://thorbis.com/billing

Organization ID: ${alert.organizationId}

This alert was generated by Thorbis Billing Monitor.
    `.trim();
  }
}

/**
 * Slack notification handler
 */
export class SlackAlertHandler implements AlertHandler {
  type: BillingAlert['type'] = 'usage_threshold';
  
  constructor(private config: SlackConfig) {}

  async handle(alert: BillingAlert): Promise<void> {
    const severity_emoji = {
      critical: 'üö®',
      high: '‚ö†Ô∏è',
      medium: 'üìä',
      low: '‚ÑπÔ∏è'
    }[alert.severity];

    const color = {
      critical: 'danger',
      high: 'warning',
      medium: 'good',
      low: '#2563eb'
    }[alert.severity];

    const slackPayload = {
      channel: this.config.channel,
      attachments: [
        {
          color,
          title: `${severity_emoji} ${alert.title}`,
          text: alert.message,
          fields: [
            {
              title: 'Severity',
              value: alert.severity.toUpperCase(),
              short: true
            },
            {
              title: 'Organization',
              value: alert.organizationId,
              short: true
            },
            {
              title: 'Time',
              value: alert.createdAt.toISOString(),
              short: true
            },
            {
              title: 'Action Required',
              value: alert.actionRequired ? 'Yes' : 'No',
              short: true
            }
          ],
          footer: 'Thorbis Billing Monitor',
          ts: Math.floor(alert.createdAt.getTime() / 1000),
          actions: alert.actionRequired ? [
            {
              type: 'button',
              text: 'View Dashboard',
              url: 'https://thorbis.com/billing'
            }
          ] : undefined
        }
      ]
    };

    try {
      await fetch(this.config.webhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(slackPayload),
      });
    } catch (error) {
      console.error('Failed to send Slack alert:', error);
    }
  }
}

/**
 * Webhook notification handler for custom integrations
 */
export class WebhookAlertHandler implements AlertHandler {
  type: BillingAlert['type'] = 'usage_threshold';
  
  constructor(private webhookUrls: string[]) {}

  async handle(alert: BillingAlert): Promise<void> {
    const payload = {
      event: 'billing.alert.created',
      data: alert,
      timestamp: new Date().toISOString(),
    };

    const requests = this.webhookUrls.map(url => 
      fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Thorbis-Event': 'billing.alert.created',
        },
        body: JSON.stringify(payload),
      }).catch(error => {
        console.error(`Webhook failed for ${url}:`, error);
      })
    );

    await Promise.allSettled(requests);
  }
}

/**
 * Console logger for development
 */
export class ConsoleAlertHandler implements AlertHandler {
  type: BillingAlert['type'] = 'usage_threshold';

  async handle(alert: BillingAlert): Promise<void> {
    const severity_symbol = {
      critical: 'üö®',
      high: '‚ö†Ô∏è',
      medium: 'üìä',
      low: '‚ÑπÔ∏è'
    }[alert.severity];

    console.log(`\n${severity_symbol} BILLING ALERT [${alert.severity.toUpperCase()}]`);
    console.log(`Title: ${alert.title}`);
    console.log(`Message: ${alert.message}`);
    console.log(`Organization: ${alert.organizationId}`);
    console.log(`Time: ${alert.createdAt.toISOString()}`);
    console.log(`Action Required: ${alert.actionRequired ? 'Yes' : 'No'}`);
    
    if (alert.data) {
      console.log(`Data:`, alert.data);
    }
    
    console.log('‚îÄ'.repeat(80));
  }
}

/**
 * Alert manager to coordinate multiple handlers
 */
export class AlertManager {
  private handlers: AlertHandler[] = [];

  constructor(private config: NotificationConfig) {
    this.setupHandlers();
  }

  private setupHandlers(): void {
    // Always add console handler for logging
    this.handlers.push(new ConsoleAlertHandler());

    // Add email handler if configured
    if (this.config.email) {
      this.handlers.push(new EmailAlertHandler(this.config.email));
    }

    // Add Slack handler if configured
    if (this.config.slack) {
      this.handlers.push(new SlackAlertHandler(this.config.slack));
    }

    // Add webhook handlers if configured
    if (this.config.webhooks && this.config.webhooks.length > 0) {
      this.handlers.push(new WebhookAlertHandler(this.config.webhooks));
    }
  }

  public async handleAlert(alert: BillingAlert): Promise<void> {
    const relevantHandlers = this.handlers.filter(handler => 
      handler.type === alert.type || handler.type === 'usage_threshold' // Default fallback
    );

    await Promise.allSettled(
      relevantHandlers.map(handler => handler.handle(alert))
    );
  }

  public addHandler(handler: AlertHandler): void {
    this.handlers.push(handler);
  }

  public removeHandler(handlerType: string): void {
    this.handlers = this.handlers.filter(h => h.constructor.name !== handlerType);
  }
}

export default AlertManager;